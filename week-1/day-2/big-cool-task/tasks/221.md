# Big Cool Task: 221

На выходных наш проект посмотрел сторонний backend-разработчик и отметил пару моментов.

1. Код для рендера HTML из React-компонентов дублируется в нескольких местах.
2. В обычных Express-проектах содержимое `app.locals` и `res.locals` автоматически попадает в шаблоны. В нашем проекте это не работает — ведь мы используем React-компоненты в качестве `views`.

Давай это исправим. В этом нам пригодится знание middleware-функций.

## Release 1. Метод res.renderComponent

Создай файл `middlewares/renderComponent.js`. Внутри него:

1. Напиши функцию, которая превращает React-компонент в HTML-код. Она должна принимать компонент и пропсы, а возвращать строку HTML-кода — с доктайпом или без.
2. Напиши middleware-функцию, которая добавляет эту функцию к объекту `res` — под названием `renderComponent`.

Подключи эту middleware-функцию в `app.js`. Найди в роутах дублирующийся код по рендеру компонентов в HTML и замени его на вызов метода `res.renderComponent`.

Запусти все тесты и проверь, что наш рефакторинг ничего не сломал. Если все работает как надо, сделай коммит с осмысленным сообщением.

## Release 2. Передача данных из res.locals и app.locals в компоненты

Улучши свою функцию для рендера компонентов — она должна передавать содержимое `res.locals` и `app.locals` внутрь компонента.

Если застрянешь, вот тебе наводящие вопросы:
1. Как получить доступ к объекту `res` из функции для рендера компонентов?
2. Как получить доступ к объекту `app`, имея доступ к объекту `res`?

Когда реализуешь передачу `locals` в компоненты, найди в роутах дублирующийся код для передачи этих же данных и удали его. Содержимое `locals` должно попадать в React-компоненты автоматически благодаря твоей middleware-функции для рендера компонентов.

Запусти все тесты и проверь, что наш рефакторинг ничего не сломал. Если все работает как надо, сделай коммит с осмысленным сообщением.

## Release 3. Хэширование паролей пользователей (опционально)
Этот релиз необязательный — мы ещё не проходили хэширование паролей. Засеки 30 минут и попробуй разобраться в том, что такое хэширование паролей и зачем оно нужно. Если не получится, просто пропусти этот релиз — мы ещё будем изучать эту тему в дальнейшем.

Для хэширования паролей тебе может пригодиться библиотека [bcrypt](https://www.npmjs.com/package/bcrypt) или встроенный в Node.js модуль [crypto](https://nodejs.org/api/crypto.html).

## Release 4. Регистрация пользователей
Давай улучшим регистрацию пользователей.

Открой роут, обрабатывающий запросы `POST /api/auth/register`. Сейчас этот обработчик лишь проверяет, что пароль и его повторение совпадают. Эта проверка нужна, но её недостаточно. Также наш роут всегда отправляет ответ с успешным статусом 200 OK, даже если проверка не пройдена. Давай исправим ситуацию.

Обнови обработчик запроса согласно требованиям:
1. Если пароль и его повторение не совпадают, отправь ответ со статусом `400 Bad Request` и сообщением "Пароли не совпадают".
2. Если какое-либо из трёх полей не заполнено, отправь ответ со статусом `400 Bad Request` и сообщением "Пожалуйста, заполните все поля".
3. Если пользователь прислал слишком слабый пароль (то есть, меньше 8 символов), отправь ответ со статусом `422 Unprocessable Entity` и сообщением "Пароль должен быть не менее 8 символов".
4. Если пользователь с такой электронной почтой уже существует, отправь ответ со статусом `409 Conflict` и сообщением "Пользователь с таким email уже существует".
   - Пока сохраняй зарегистрированных пользователей в `app.locals` — это не самый лучший вариант, но пока сойдёт. В будущем мы будем хранить пользователей в базе данных.
5. Если все проверки прошли успешно, создай нового пользователя в `app.locals`. Отправь ответ со статусом `201 Created` и сообщением "Пользователь (email) зарегистрирован". Впиши соответствующий email в это сообщение.
6. Если на сервере произошла неожиданная ошибка, не связанная с клиентским запросом, отправь ответ со статусом `500 Internal Server Error` и сообщением "Произошла ошибка на сервере. Пожалуйста, попробуйте позже или отправьте сообщение администратору сайта (здесь укажи email администратора)". Впиши соответствующий email в это сообщение.

Если ты ещё и захэшируешь пароль пользователя — твоя обработка запросов на регистрацию восхитительна!

Проверь в браузере работу своего роута — используй вкладку "Сеть" ("Network") в инструментах разработчика для проверки результатов запроса.

Запусти тесты в разделе "Регистрация пользователей" и проверь, что твой роут работает правильно. Если все тесты проходят, сделай коммит с осмысленным сообщением.

## Release 5. Ограничение количества запросов на регистрацию (необязательно)

Попробуй реализовать подход "rate limiting" для регистрации — например, если пользователь пытается зарегистрироваться больше 5 раз в 1 минуту, отправляй ответ со статусом `429 Too Many Requests` и сообщением "Пожалуйста, попробуйте позже".

Не забудь включить заголовок `Retry-After` в ответе, чтобы клиент знал, через какое время можно повторить запрос.

Этот релиз необязательный, но если тебя интересует back-end разработка — попробуй реализовать его. Засеки 30 минут и попробуй разобраться в том, как ограничить количество запросов на регистрацию. Если не получится, просто пропусти этот релиз. Эта тема не входит в программу Elbrus Bootcamp, но ты можешь изучить её самостоятельно в дальнейшем, если будет такое желание.

Также посмотри, есть ли уже готовые middleware для Express, которые реализуют rate limiting. Попробуй подключить какую-нибудь из них и проверь, как она работает.
